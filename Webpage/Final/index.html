<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    background-color: white;
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
  kbd {
    color: #121212;
  }
</style>
<title>CS 184 Path Tracer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">

<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
</script>
<script id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>

</head>


<body>

    <h1 align="middle">CS 184 Final Project: Cool Shaders</h1>
    <h2 align="middle">Final Report</h2>
    <h2 align="middle">Group Members: Alexander Sun, Ryland Hu, Sydney Tang, Jaeha Yi</h2>

    <h2 align="middle">Website URL: <a href="https://catttttttt.github.io/Computer-graphics-and-imaging-final-project-webpage/Webpage/Final/index.html">HERE</a></h2>

    
    <br><br>
    

    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
            <video width="80%" autoplay muted>
              <source src="./images/webpage/finalVideo.mp4" type="video/mp4" width="100%">
            Your browser does not support the video tag.
            </video>
          </td>

        </tr>
      </table>
    </div>
    <br>

    <div>
      

    <h2 align="middle">Abstract</h2>
    <p>      
      In this project, we implemented a few non-photorealistic shader in OpenGL and Unity. Building off of the code in homework 4, we created a toon shader (with textured shadows) and a hatching shader in GLSL.  
      We integrated these shaders into the Unity game engine to render additional 3D meshes and create a watercolor shader and paint-like shader, which are both post-processing effects.  
    </p>
    <br>

    <h2 align="middle"></h2>

    </div>

    <h2 align="middle">Technical Approaches </h2>

    <br>

      <h3 align="middle">Toon shader</h3>
        <p>
          We created a shader with discrete brightness levels by editting the phong shader in order to get flat colors with different levels of RGB value. In addition, we added rim lighting in order to draw the outline of the objects, which makes them look more like animation.
        </p>
        <p>
          Comparing with the reference, we edited the texture shader on top of single-color toon shader to put in textures as shades, and made it so that the texture displayed as a flat image parallel to the plane.
        </p>   
        <table style="width:100%">
          <tbody><tr align="center">
            <td>
                <img src="./images/toon/texture_2.png" align="middle" width="50%">
                <figcaption align="middle">Polkadot texture used as shade</figcaption>
            </td>
            <td>
                <img src="images/toon/texture_2_grid.png" align="middle" width="68%">
                <figcaption align="middle">Other texture used as shade</figcaption>
            </td>
          </tr>
        </tbody></table>    



      <h3 align="middle">Hatching shader</h3>
        <p>
          We first utilized the Phong lighting model to calculate diffuse and specular lighting contributions based on the light position, camera position, surface normal, and view direction.
        </p>
        <p>
          Then, we sampled from multiple tonal art maps at different mipmap levels, depending on the brightness values computed from the lighting calculations. We interpolated between two nearest levels to ensure smooth transitions between different levels of mipmap.
        </p>
        <p>
          Comparing with the reference, we implemented a simplified version of the tonal blending technique, focusing on blending between textures based on brightness values rather than a comprehensive 6-way blend. Since GLSL only allow 4 textures imported, we restrict our levels to 4 only. In addition, it's hard to find tonal art maps with high resolution online. Hence, we used pure white as a part of mipmaps.
        </p>
        <table style="width:100%">
          <tbody><tr align="center">
            <td>
                <img src="./images/hatching/textures.png" align="middle" width="70%">
                <figcaption align="middle">Different levels of mipmap used for hatching</figcaption>
            </td>
          </tr>
        </tbody></table>
        <br><br>

        <h3 align="middle">Painter-like shader</h3>
        <p>
          <b>Approach:</b> We utilized Kuwahara filters to create a paint-like shader, which is applied in the post-processing step after objects are rendered. The Kuwahara filter reduces image noise and preserves edges, creating an image that looks painted. 
        </p>  
        <p>
          The algorithm calculates the average and variance (i.e. standard deviation) of pixel values in four regions surrounding the pixel. The area with the smallest variance will be chosen, and that area's average value will be the pixel's value. 
          Edges avoid blurring because pixels on one side of the edge favor the region on its own side (due it being more homogenous). This preverses the distinct sides of edges. 
        </p>
        <p>
          
          
        </p>
        <p>
          <b>Challenges:</b> We had difficulties modifying the homework 4's OpenGL pipeline to allow post-processing filters and custom meshes, so we decided to implement this shader in the Unity game engine. This required time in learning Unity's shaders and render pipeline. Another challenge was that the initial Kuwahara filter had blocky artifacts, especially in high frequency regions, like hair. 
          We found and utilized a reference for a Kuwahara shader using Sobel edge detection (by Giacomo Tagliaventi), which rotated filter regions to match the orientation of the edge. This does a great job of preserving edges and removing artifacts. 
        </p>
        <table style="width:100%">
          <tbody><tr align="center">
            <td>
                <img src="images/painter/kuwahara0.png" align="middle" width="50%">
                <figcaption align="middle">simple kuwahara filter</figcaption>
  
            </td>
            <td>
                <img src="images/painter/kuwahara1.png" align="middle" width="50%">
                <figcaption align="middle">advanced kuwahara filter with edge-oriented regions</figcaption>
            </td>
          </tr>
        </tbody></table>
        <p>
          <b>Lessons:</b> The initial Kuwahara filter was provided in GLSL from "Anisotropic Kuwahara Filtering on the GPU," and we learned to translate GLSL to Unity's HLSL shaders. None of us had Unity shader experience, and we learned to modify Unity's fragment shaders, pass variables to shaders, and apply post-processing in Unity, which requires the shader being attached to Unity's camera object. 
        </p>
<br>
        <h3 align="middle">Watercolor simulation shader</h3>
        <p>
          We achieve a watercolor-like effect by modeling the movement of water and pigments. Each pixel of the input image is thought of as a group of paper fibers, which have an absorbency, water and pigment content, etc. Each pixel communicates with its neighbors, which allows us to model diffusion effects of the watercolor. 
        </p>

        <div style="text-align: center;">
            <figure>
                <img src="./images/watercolor1/pixel_diagram.png" alt="Example GIF" style="width: 30%;">
                <figcaption>Pixel communication structure</figcaption>
            </figure>
        </div>

        <p> Each timestep of our simulation consists of the following:
            <ol>
                <li>Surface tension: The water and pigments on the surface of the paper experience surface tension, which is an attraction force. Let W_s be a $w * h$ array of the water levels at each pixel, and P_s be a $w * h * 3$ array of the pigment CMY levels at each pixel. 

                For surface tension in the horizontal direction, we have
                \[D_x = s * \frac{W[i][j+1] - W[i][j]}{W[i][j]}\]
                \[D_y = s * \frac{W[i+1][j] - W[i][j]}{W[i][j]}\]

                Where $D_x$ is the percentage of water/pigment content to transport right, and $s$ is the constant of surface tension. A negative value represents transport left. Similarly for $D_y$.</li>
                <li>Gravity: The water and pigments on the surface of the paper experience gravity, which disperses them. We achieve this by a convolution with the filter 

                    \[
                        \begin{bmatrix}
                        g/8 & g/8 & g/8 \\
                        g/8 & 1-g & g/8 \\
                        g/8 & g/8 & g/8 \\
                        \end{bmatrix}
                    \]

                This captures how each pixel's water and pigment content is blended with its neighbors'. Here, $g$ is a gravitational constant. We apply this convolution to $W_s$, as well as to each channel of $P_s$.
                </li>
                <li>Paper absorption: In our simulation, the canvas gradually absorbs the water and pigments, locking them into place. Let $A$ be a $w * h$ array of absorbancy values, $W_i$ and $P_i$ be the water and pigment content infused in the paper. We have 
                    \[D = k * A * W_s\]
                where $D$ is the water transported from the surface to the paper. A similar equation governs the transport of each pigment.
                </li>
            </ol>

            To render the final image, we take the RGB values of our paper texture and subtract the CMY pigment values. The paper texture adds an artistic touch to our result.
        </p>

        <p>
            This watercolor shader was heavily inspired by "Modeling Watercolor by Simulating Diffusion, Pigment, and Paper Fibers" by David Small. While our concepts are similar, some equations governing the simulation and all code are original. In particular, we modeled the effect of gravity by a convolution, while Small had a constant force pulling towards the bottom-right corner of the paper. We additionally vectorized all of the operations for efficiency.
        <p>
    <br>

    <h2 align="middle">Results </h2>
    <p>      
      Your final images, animations, video of your system (whichever is relevant). You can include results that you think show off what you built but that you did not have time to go over on presentation day.

       
<br>
      <h3 align="middle">Toon shader</h3>
      <table style="width:100%">
        <tbody><tr align="center">
          <td>
              <img src="images/toon/phong_cloth.png" align="middle" width="50%">
              <figcaption align="middle">front view after simulation - greyscale</figcaption>
          </td>
          <td>
              <img src="images/toon/phong_cloth_blue.png" align="middle" width="50%">
              <figcaption align="middle">front view after simulation - blue</figcaption>
          </td>
        </tr>
      </tbody></table>
      <br>
      <div align="middle">
        <table style="width:100%">
          <tbody><tr align="center">
            <td>
                <img src="images/toon/polkadot_cloth.png" align="middle" width="50%">
                <figcaption align="middle">side view after simulation - polkadot </figcaption>
            </td>
            <td>
                <img src="images/toon/polkadot_cloth2.png" align="middle" width="50%">
                <figcaption align="middle">front view after simulation - polkadot</figcaption>
            </td>
          </tr>
        </tbody></table>
        <br>
        <div align="middle">
          <table style="width:100%">
            <tbody><tr align="center">
              <td>
                  <img src="images/toon/grid_cloth.png" align="middle" width="50%">
                  <figcaption align="middle">side view after simulation - grid </figcaption>
              </td>
              <td>
                  <img src="images/toon/grid_cloth2.png" align="middle" width="50%">
                  <figcaption align="middle">front view after simulation - grid</figcaption>
              </td>
            </tr>
          </tbody></table>


<br>
      <h3 align="middle">Hatching shader</h3>
      <table style="width:100%">
        <tbody><tr align="center">
          <td>
              <img src="images/hatching/cloth&sphere.png" align="middle" width="50%">
              <figcaption align="middle">front view before simulation - hatching </figcaption>

          </td>
          <td>
              <img src="images/hatching/falling_cloth_top.png" align="middle" width="50%">
              <figcaption align="middle">top view during simulation - hatching</figcaption>
          </td>
        </tr>
      </tbody></table>

      <table style="width:100%">
        <tbody><tr align="center">
          <td>
              <img src="images/hatching/falling_cloth_front.png" align="middle" width="50%">
              <figcaption align="middle">front view during simulation - hatching</figcaption>
          </td>
          <td>
              <img src="images/hatching/cloth_on_sphere.png" align="middle" width="50%">
              <figcaption align="middle">front view after simulation - hatching</figcaption>
          </td>
        </tr>
      </tbody></table>

      <br>

      <h3 align="middle">Shaders in Unity</h3>
      <table style="width:100%">
        <tbody><tr align="center">
          <td>
              <img src="images/unity/unity0.png" align="middle" width="80%">
              <figcaption align="middle">From right to left: textured shadow toon shader, toon shader, hatching shader, phong shader</figcaption>
          </td>
        </tr>
      </tbody></table>
      <br>

      <table style="width:100%">
        <tbody><tr align="center">
          <td>
              <img src="images/unity/unity1.png" align="middle" width="50%">
              <figcaption align="middle">paint-like shader</figcaption>
          </td>
          <td>
              <img src="images/unity/unity2.png" align="middle" width="50%">
              <figcaption align="middle">watercolor shader</figcaption>
          </td>
        </tr>
      </tbody></table>

      <table style="width:100%">
        <tbody><tr align="center">
          <td>
              <img src="images/unity/unity3.png" align="middle" width="50%">
              <figcaption align="middle">paint-like shader - zoomed in</figcaption>
          </td>
          <td>
              <img src="images/unity/unity4.png" align="middle" width="50%">
              <figcaption align="middle">watercolor shader - zoomed in</figcaption>
          </td>
        </tr>
      </tbody></table>
      <br><br>

      <h3 align="middle">Watercolor simulation shader</h3>
      <table style="width:80%">
        <tbody><tr align="center">
          <td>
              <img src="./images/watercolor1/fruits1_crop.png" align="middle" width="100%">
              <figcaption align="middle">original</figcaption>
          </td>
          <td>
              <img src="./images/watercolor1/fruits_cropp.gif" align="middle" width="100%">
              <figcaption align="middle">simulation</figcaption>
          </td>
        </tr>
      </tbody></table>


    </p>


    <br>
    <h3 align="middle">Shaders in Blender</h3>
    <div align="middle">
      <table style="width:100%">
        <tr align="center">
          <td>
            <video width="80%" autoplay muted>
              <source src="./images//webpage/blenderVideo.mp4" type="video/mp4" width="100%">
            Your browser does not support the video tag.
            </video>
          </td>

        </tr>
      </table>
    </div>
    <ul align="left">
    <p>
      After implementing a few shaders in HW4, we wanted to extend our shaders to other meshes. 
      Our first option that we considered was trying to use Blender's custom shader options, which 
      could be written in Open Shading Language (OSL). However, as we looked further into it, we found 
      the language to be very limiting. For example, you were only allowed to use certain pre-made BSDFs, 
      you could not access certain global variables like the position of the lights, and the data types 
      were very limited with what they could do. Additionally, there was also a lack of resources online, 
      and there was very little debugging resources, so it was overall very difficult to get anything to work. 
    </p>
    <p> 
      Because of all these limitations, we decided to go with Unity to build more in-depth shaders. 
      We did however, get to implement a simple toon shader in Blender with the time we were given. 

    </p>
  </ul>


    <br>
    <br>

    <h2 align="middle">References</h2>
    <h3 align="middle">Toon shader</h3>
    <ul align="left">
      <li><a href="https://en.wikibooks.org/wiki/GLSL_Programming/Unity/Toon_Shading">Toon Shading</a>
      <li><a href="https://cglearn.eu/pub/advanced-computer-graphics/non-photorealistic-rendering">Non-Photorealistic Rendering</a></li>
      <li><a href="https://janhalozan.com/2017/08/12/phong-shader/">Implementing a Phong Shader in Unity</a></li>
    </ul>  

    <h3 align="middle">Hatching shader</h3>
    <ul align="left">
      <li><a href="https://hhoppe.com/hatching.pdf">Real-Time Hatching</a></li>
      <li><a href="https://agatedragon.blog/2024/02/12/simple-outline-shader/">Simple Outline Shader</a>
      <li><a href="https://lettier.github.io/3d-game-shaders-for-beginners/outlining.html">3D Game Shaders - Outlining</a></li>
    </ul>  

    <h3 align="middle">Paint-like shader</h3>
    <ul align="left">
      <li><a href="https://stackoverflow.com/questions/5830139/how-can-i-do-these-image-processing-tasks-using-opengl-es-2-0-shaders">Image Processing Tasks using OpenGL - oil painting conversion</a></li>
      <li><a href="https://www.youtube.com/watch?v=__vR3H5g5Qk">Hybrid Kuwahara Filtering - Unity Shader</a>
    </ul>  

    <h3 align="middle">Watercolor simulation shader</h3>
    <ul align="left">
      David Small. Simulating Watercolor by Modeling Diffusion, Pigment, and Paper Fibers.‚Äù In Proceedings of SPIE '91. February 1991.
    </ul>  
    
    <br>

    <h2 align="middle">Contributions</h2>
    <p align="left">
      Alexander Sun: Wrote watercolor simulation, co-wrote toon and watercolor shaders, experimented with rendering custom meshes using homework 4 code, helped debug shaders, helped create the website, and made the videos. 
    </p>

    <p align="left">
      Ryland Hu: Implemented the hatching shader in OpenGL, helped create the toon shader, researched toon shading methods and drawing shadows, helped debug shaders and render objects, helped create textures and the website. 
    </p>

    <p align="left">
      Sydney Tang: Integrated the hatching shader into Unity, experimented with custom shaders in Blender, researched different shader styles and renderers, helped rendering objects, helped create textures and video, and created the slides. 
    </p>

    <p align="left">
      Jaeha Yi: Wrote the paint-like shader, helped create the toon shader, integrated watercolor and toon shaders into Unity, researched Unity's render pipeline, helped rendering objects in Unity, and helped create the website. 
    </p>
    
    <br>

    


</body>